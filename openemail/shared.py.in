# shared.py.in
#
# Authors: kramo
# Copyright 2025 Mercata Sagl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""Shared data across the application."""

from collections import defaultdict
from pathlib import Path
from typing import Any, Callable, Iterable

from gi.repository import Adw, Gdk, Gio, GLib, GObject

from openemail import network
from openemail.message import Message
from openemail.network import (
    fetch_broadcasts,
    fetch_contacts,
    fetch_link_messages,
    fetch_profile,
    fetch_profile_image,
)
from openemail.user import Address, Profile, User

APP_ID = "@APP_ID@"
VERSION = "@VERSION@"
PREFIX = "@PREFIX@"
PROFILE = "@PROFILE@"

settings = Gio.Settings.new(APP_ID)
state_settings = Gio.Settings.new(f"{APP_ID}.State")
secret_service = f"{APP_ID}.Keys"
network.cache_dir = Path(GLib.get_user_cache_dir()) / "openemail"

user: User | None = None

broadcasts: list[Message] = []
link_messages: list[Message] = []
outbox: list[Message] = []


class GProfile(GObject.Object):
    """A GObject representation of a user profile."""

    __gtype_name__ = "GProfile"

    has_name = GObject.Property(type=bool, default=False)
    image = GObject.Property(type=Gdk.Paintable)

    _profile: Profile | None = None
    _address: str | None = None
    _name: str | None = None

    @property
    def profile(self) -> Profile | None:
        """The profile of the user."""
        return self._profile

    @profile.setter
    def profile(self, profile: Profile | None) -> None:
        self._profile = profile

        if not profile:
            return

        self.address = str(profile.address)
        self.name = str(profile.required["name"])

    @GObject.Property(type=str)
    def address(self) -> str | None:
        """Get the user's Mail/HTTPS address."""
        return self._address

    @address.setter
    def address(self, address: str) -> None:
        self._address = address

        if not self.name:
            self.name = address

    @GObject.Property(type=str)
    def name(self) -> str | None:
        """Get the user's name."""
        return self._name

    @name.setter
    def name(self, name: str) -> None:
        self._name = name
        self.has_name = name != self.address


profiles: defaultdict[Address, GProfile] = defaultdict(GProfile)
address_book = Gio.ListStore.new(GProfile)

_loading = 0


def is_loading() -> bool:
    """Check whether or not an update is currently ongoing."""
    return bool(_loading)


def update_user_profile(
    callback: Callable[[Profile | None, Gdk.Paintable | None], Any] | None = None,
) -> None:
    """Update the profile of the user by fetching new data remotely."""
    global _loading

    def update_profile() -> None:
        global _loading

        if user:
            profiles[user.address].profile = fetch_profile(user.address)

            try:
                profiles[user.address].image = Gdk.Texture.new_from_bytes(
                    GLib.Bytes.new(fetch_profile_image(user.address))  # type: ignore
                )
            except GLib.Error:
                profiles[user.address].image = None

        _loading -= 1

        if callback and user:
            GLib.idle_add(
                callback,
                profiles[user.address].profile,
                profiles[user.address].image,
            )

    _loading += 1
    GLib.Thread.new(None, update_profile)


def update_address_book(callback: Callable[[], Any] | None = None) -> None:
    """Update the address book of the user by fetching new data remotely."""
    global _loading

    def update_address_store(contacts: Iterable[Address]) -> None:
        global _loading
        global address_book
        global profiles

        address_book.remove_all()
        for contact in contacts:
            profiles[contact].address = str(contact)
            address_book.append(profiles[contact])

        _loading -= 1

        if callback:
            GLib.idle_add(callback)

    def update_contacts() -> None:
        global _loading
        if not user:
            _loading -= 1
            return

        GLib.idle_add(update_address_store, fetch_contacts(user))

    _loading += 1
    GLib.Thread.new(None, update_contacts)


def update_profiles() -> None:
    """Update the profiles for contacts in the user's address book by fetching new data remotely."""
    global _loading

    running = 0

    def update_profile(contact: Address) -> None:
        global _loading
        global profiles

        profiles[contact].profile = fetch_profile(contact)
        _loading -= 1

    def update_profile_image(contact: Address) -> None:
        global _loading
        global profiles

        try:
            GLib.idle_add(
                profiles[contact].set_property,
                "image",
                Gdk.Texture.new_from_bytes(
                    GLib.Bytes.new(image)  # type: ignore
                )
                if (image := fetch_profile_image(contact))
                else None,
            )
        except GLib.Error:
            GLib.idle_add(profiles[contact].set_property, "image", None)

        _loading -= 1

    if not user:
        return

    for contact in address_book:
        _loading += 1
        GLib.Thread.new(None, update_profile, Address(contact.address))
        GLib.Thread.new(None, update_profile_image, Address(contact.address))


def update_broadcasts_list(
    callback: Callable[[list[Message]], Any] | None = None,
) -> None:
    """Update the broadcasts list of the user by fetching new data remotely."""
    global _loading

    running = len(address_book)
    new_broadcasts: list[Message] = []

    def fetch_done_cb() -> None:
        global _loading
        nonlocal running
        global broadcasts

        running -= 1
        if not running:
            new_broadcasts.sort(
                key=lambda message: message.envelope.date,
                reverse=True,
            )

            broadcasts = new_broadcasts
            _loading -= 1

            if callback:
                GLib.idle_add(callback, broadcasts)

    def update_broadcasts(author: Address) -> None:
        global broadcasts
        nonlocal new_broadcasts

        if user:
            new_broadcasts += fetch_broadcasts(user, author)

        fetch_done_cb()

    _loading += 1
    for contact in address_book:
        GLib.Thread.new(None, update_broadcasts, Address(contact.address))


def update_messages_list(
    callback: Callable[[list[Message]], Any] | None = None,
) -> None:
    """Update the messages list of the user by fetching new data remotely."""
    global _loading

    running = len(address_book)
    new_messages: list[Message] = []

    def fetch_done_cb() -> None:
        global _loading
        nonlocal running
        global link_messages

        running -= 1
        if not running:
            new_messages.sort(
                key=lambda message: message.envelope.date,
                reverse=True,
            )

            link_messages = new_messages
            _loading -= 1

            if callback:
                GLib.idle_add(callback, link_messages)

    def update_messages(author: Address) -> None:
        global link_messages
        nonlocal new_messages

        if user:
            new_messages += fetch_link_messages(user, author)

        fetch_done_cb()

    _loading += 1
    for contact in address_book:
        GLib.Thread.new(None, update_messages, Address(contact.address))


def update_outbox(
    callback: Callable[[list[Message]], Any] | None = None,
) -> None:
    """Update the outbox of the user by fetching new data remotely."""
    global _loading

    if not user:
        return

    new_messages: list[Message] = []

    def update_messages(author: Address) -> None:
        global _loading
        global outbox
        nonlocal new_messages

        if user:
            new_messages += fetch_link_messages(user, author)
            new_messages += fetch_broadcasts(user, author)

        new_messages.sort(
            key=lambda message: message.envelope.date,
            reverse=True,
        )

        outbox = new_messages
        _loading -= 1

        if callback:
            GLib.idle_add(callback, outbox)

    _loading += 1
    GLib.Thread.new(None, update_messages, user.address)
