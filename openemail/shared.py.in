# shared.py.in
#
# Authors: kramo
# Copyright 2025 Mercata Sagl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""Shared data across the application."""

from collections import defaultdict
from pathlib import Path
from re import sub
from typing import Any, Callable, Iterable

from gi.repository import Adw, Gdk, Gio, GLib, GObject

from openemail import network
from openemail.crypto import Key
from openemail.message import Message
from openemail.network import (
    fetch_broadcasts,
    fetch_contacts,
    fetch_link_messages,
    fetch_profile,
    fetch_profile_image,
)
from openemail.user import Address, Profile, User

APP_ID = "@APP_ID@"
VERSION = "@VERSION@"
PREFIX = "@PREFIX@"
PROFILE = "@PROFILE@"

settings = Gio.Settings.new(APP_ID)
state_settings = Gio.Settings.new(f"{APP_ID}.State")
secret_service = f"{APP_ID}.Keys"
network.cache_dir = Path(GLib.get_user_cache_dir()) / "openemail"

user: User | None = None


class MailProfile(GObject.Object):
    """A GObject representation of a user profile."""

    __gtype_name__ = "MailProfile"

    has_name = GObject.Property(type=bool, default=False)
    image = GObject.Property(type=Gdk.Paintable)

    _profile: Profile | None = None
    _address: str | None = None
    _name: str | None = None

    @property
    def profile(self) -> Profile | None:
        """The profile of the user."""
        return self._profile

    @profile.setter
    def profile(self, profile: Profile | None) -> None:
        self._profile = profile

        if not profile:
            return

        self.address = str(profile.address)
        self.name = str(profile.required["name"])

    @GObject.Property(type=str)
    def address(self) -> str | None:
        """Get the user's Mail/HTTPS address."""
        return self._address

    @address.setter
    def address(self, address: str) -> None:
        self._address = address

        if not self.name:
            self.name = address

    @GObject.Property(type=str)
    def name(self) -> str | None:
        """Get the user's name."""
        return self._name

    @name.setter
    def name(self, name: str) -> None:
        self._name = name
        self.has_name = name != self.address


profiles: defaultdict[Address, MailProfile] = defaultdict(MailProfile)
address_book = Gio.ListStore.new(MailProfile)


class MailMessage(GObject.Object):
    """A Mail/HTTPS message."""

    __gtype_name__ = "MailMessage"

    message: Message | None = None

    name = GObject.Property(type=str)
    date = GObject.Property(type=str)
    subject = GObject.Property(type=str)
    contents = GObject.Property(type=str)
    stripped_contents = GObject.Property(type=str)
    profile_image = GObject.Property(type=Gdk.Paintable)

    _name_binding: GObject.Binding | None = None
    _image_binding: GObject.Binding | None = None

    def __init__(self, message: Message | None = None, **kwargs: Any) -> None:
        super().__init__(**kwargs)

        if message:
            self.set_from_message(message)

    def set_from_message(self, message: Message) -> None:
        """Update properties of the row from `message`."""
        self.message = message

        self.date = message.envelope.date.strftime("%x")
        self.subject = message.envelope.subject
        self.body = message.body
        self.stripped_contents = (
            sub(r"\n+", " ", message.body) if message.body else None
        )

        if self._name_binding:
            self._name_binding.unbind()
        self._name_binding = profiles[message.envelope.author].bind_property(
            "name", self, "name", GObject.BindingFlags.SYNC_CREATE
        )

        if self._image_binding:
            self._image_binding.unbind()
        self._image_binding = profiles[message.envelope.author].bind_property(
            "image", self, "profile-image", GObject.BindingFlags.SYNC_CREATE
        )


broadcasts = Gio.ListStore.new(MailMessage)
link_messages = Gio.ListStore.new(MailMessage)
outbox = Gio.ListStore.new(MailMessage)


_loading = 0


def is_loading() -> bool:
    """Check whether or not an update is currently ongoing."""
    return bool(_loading)


def update_user_profile(
    callback: Callable[[Profile | None, Gdk.Paintable | None], Any] | None = None,
) -> None:
    """Update the profile of the user by fetching new data remotely."""
    global _loading

    def update_profile() -> None:
        global _loading

        if user:
            if profile := fetch_profile(user.address):
                user.public_signing_key = profile.required["signing-key"].value
                if key := profile.optional.get("encryption-key"):
                    user.public_encryption_key = key.value

            profiles[user.address].profile = profile

            try:
                profiles[user.address].image = Gdk.Texture.new_from_bytes(
                    GLib.Bytes.new(fetch_profile_image(user.address))  # type: ignore
                )
            except GLib.Error:
                profiles[user.address].image = None

        _loading -= 1

        if callback and user:
            GLib.idle_add(
                callback,
                profiles[user.address].profile,
                profiles[user.address].image,
            )

    _loading += 1
    GLib.Thread.new(None, update_profile)


def update_address_book(callback: Callable[[], Any] | None = None) -> None:
    """Update the address book of the user by fetching new data remotely."""
    global _loading

    def update_address_store(contacts: Iterable[Address]) -> None:
        global _loading
        global address_book
        global profiles

        address_book.remove_all()
        for contact in contacts:
            profiles[contact].address = str(contact)
            address_book.append(profiles[contact])

        _loading -= 1

        if callback:
            GLib.idle_add(callback)

    def update_contacts() -> None:
        global _loading
        if not user:
            _loading -= 1
            return

        GLib.idle_add(update_address_store, fetch_contacts(user))

    _loading += 1
    GLib.Thread.new(None, update_contacts)


def update_profiles() -> None:
    """Update the profiles for contacts in the user's address book by fetching new data remotely."""
    global _loading

    running = 0

    def update_profile(contact: Address) -> None:
        global _loading
        global profiles

        profiles[contact].profile = fetch_profile(contact)
        _loading -= 1

    def update_profile_image(contact: Address) -> None:
        global _loading
        global profiles

        try:
            GLib.idle_add(
                profiles[contact].set_property,
                "image",
                Gdk.Texture.new_from_bytes(
                    GLib.Bytes.new(image)  # type: ignore
                )
                if (image := fetch_profile_image(contact))
                else None,
            )
        except GLib.Error:
            GLib.idle_add(profiles[contact].set_property, "image", None)

        _loading -= 1

    if not user:
        return

    for contact in address_book:
        _loading += 2
        GLib.Thread.new(None, update_profile, Address(contact.address))
        GLib.Thread.new(None, update_profile_image, Address(contact.address))


def update_broadcasts_list() -> None:
    """Update the broadcasts list of the user by fetching new data remotely."""
    global _loading

    running = len(address_book)
    new_broadcasts: list[Message] = []

    def update_broadcasts_store() -> None:
        global _loading
        global broadcasts
        nonlocal new_broadcasts

        broadcasts.remove_all()
        for broadcast in new_broadcasts:
            broadcasts.append(MailMessage(broadcast))

        _loading -= 1

    def fetch_done_cb() -> None:
        nonlocal running

        running -= 1
        if not running:
            GLib.idle_add(update_broadcasts_store)

    def update_broadcasts(author: Address) -> None:
        global broadcasts
        nonlocal new_broadcasts

        if user:
            new_broadcasts += fetch_broadcasts(user, author)

        fetch_done_cb()

    _loading += 1
    for contact in address_book:
        GLib.Thread.new(None, update_broadcasts, Address(contact.address))


def update_messages_list() -> None:
    """Update the messages list of the user by fetching new data remotely."""
    global _loading

    running = len(address_book)
    new_messages: list[Message] = []

    def update_messages_store() -> None:
        global _loading
        global link_messages
        nonlocal new_messages

        link_messages.remove_all()
        for message in new_messages:
            link_messages.append(MailMessage(message))

        _loading -= 1

    def fetch_done_cb() -> None:
        nonlocal running

        running -= 1
        if not running:
            GLib.idle_add(update_messages_store)

    def update_messages(author: Address) -> None:
        global link_messages
        nonlocal new_messages

        if user:
            new_messages += fetch_link_messages(user, author)

        fetch_done_cb()

    _loading += 1
    for contact in address_book:
        GLib.Thread.new(None, update_messages, Address(contact.address))


def update_outbox() -> None:
    """Update the outbox of the user by fetching new data remotely."""
    global _loading

    if not user:
        return

    new_messages: list[Message] = []

    def update_messages_store() -> None:
        global _loading
        global outbox
        nonlocal new_messages

        outbox.remove_all()
        for message in new_messages:
            outbox.append(MailMessage(message))

        _loading -= 1

    def update_messages(author: Address) -> None:
        global _loading
        global outbox
        nonlocal new_messages

        if user:
            new_messages += fetch_link_messages(user, author)
            new_messages += fetch_broadcasts(user, author)

        GLib.idle_add(update_messages_store)

    _loading += 1
    GLib.Thread.new(None, update_messages, user.address)
